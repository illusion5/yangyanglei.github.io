<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[自动部署博客到服务器]]></title>
    <url>%2F2017%2F11%2F29%2Fauto_eploy_blog_to_server%2F</url>
    <content type="text"><![CDATA[前言我们可以把静态blog部署到github和coding，但是如果我们有自己服务器，我们也可以部署到自己的服务器，这样即安全访问速度还快。本文使用git及nginx实现自动部署到服务器及可以通过ip或域名访问到博客。 自动部署到服务器配置git服务器搭建前文已经搭建过请参考git服务器搭建,这里不在说明 创建hexoblog.git项目使用xshell连接服务器 123456789[root@mini01 ~]# mkdir /home/git/repository/hexoblog.git #创建hexoblog.git项目[root@mini01 ~]# cd /home/git/repository/[root@mini01 repository]# ll总用量 0drwxr-xr-x. 7 git git 119 11月 29 16:03 gittest.gitdrwxr-xr-x. 2 root root 6 11月 29 17:54 hexoblog.git[root@mini01 repository]# git init --bare ./hexoblog.git/ #初始化裸仓库初始化空的 Git 版本库于 /home/git/repository/hexoblog.git/[root@mini01 repository]# chown -R git:git hexoblog.git/ #改变拥有者 创建git钩子借助git钩子实现自动部署 123456789101112131415161718192021222324[root@mini01 repository]# cd hexoblog.git/ #进入hexoblog.git[root@mini01 hexoblog.git]# ll总用量 12drwxr-xr-x. 2 git git 6 11月 29 17:57 branches-rw-r--r--. 1 git git 66 11月 29 17:57 config-rw-r--r--. 1 git git 73 11月 29 17:57 description-rw-r--r--. 1 git git 23 11月 29 17:57 HEADdrwxr-xr-x. 2 git git 262 11月 29 18:03 hooksdrwxr-xr-x. 2 git git 21 11月 29 17:57 infodrwxr-xr-x. 4 git git 30 11月 29 17:57 objectsdrwxr-xr-x. 4 git git 31 11月 29 17:57 refs[root@mini01 hexoblog.git]# cd hooks/[root@mini01 hooks]# ll总用量 44-rwxr-xr-x. 1 git git 452 11月 29 17:57 applypatch-msg.sample-rwxr-xr-x. 1 git git 896 11月 29 17:57 commit-msg.sample-rwxr-xr-x. 1 git git 189 11月 29 17:57 post-update.sample-rwxr-xr-x. 1 git git 398 11月 29 17:57 pre-applypatch.sample-rwxr-xr-x. 1 git git 1704 11月 29 17:57 pre-commit.sample-rwxr-xr-x. 1 git git 1239 11月 29 17:57 prepare-commit-msg.sample-rw-r--r--. 1 git git 1348 11月 29 17:57 pre-push.sample-rwxr-xr-x. 1 git git 4951 11月 29 17:57 pre-rebase.sample-rwxr-xr-x. 1 git git 3611 11月 29 17:57 update.sample[root@mini01 hooks]# vim post-receive #创建并编辑post-receive文件 在文件中输入一下内容 12!/bin/bashgit --work-tree=/www/hexo checkout -f 保存并退出 123456[root@mini01 hooks]# chown git:git post-receive #修改文件所属用户及用户组[root@mini01 hooks]# chmod +x post-receive #添加可执行权限[root@mini01 hooks]# cd /[root@mini01 /]# mkdir -p /www/hexo #创建目录[root@mini01 /]# chown git:git www/ #修改文件所属用户及用户组[root@mini01 www]# chown git:git /www/hexo/ hexo博客设置打开网站配置文件_config.yml，再最后一行添加 1myServer: git@你的服务器地址:/home/git/repository/hexoblog.git,master 然后本地进入Git Bash界面 12345678Administrator@AFOII-701050022 MINGW64 /e$ cd d:Administrator@AFOII-701050022 MINGW64 /d$ cd hexo/Administrator@AFOII-701050022 MINGW64 /d/hexo (master)$ hexo gAdministrator@AFOII-701050022 MINGW64 /d/hexo (master)$ hexo d 这时连接服务器查看/www/hexo目录会发现你本地编译的静态页面效果如下 现在已经实现自动部署项目到服务器，接下来我们需要实现能够访问到这些静态页面。 访问页面配置nginx安装配置1[root@mini01 ~]# yum install -y nginx 如果报错如下错误的话 12345678Loaded plugins: fastestmirror, securityLoading mirror speeds from cached hostfile * base: mirrors.163.com * extras: mirrors.sohu.com * updates: mirrors.aliyun.comSetting up Install ProcessNo package nginx available.Error: Nothing to do 则需： 1[root@mini01 ~]# rpm -ivh http://nginx.org/packages/centos/6/noarch/RPMS/nginx-release-centos-6-0.el6.ngx.noarch.rpm 然后再执行yum install -y nginx就行了 1234[root@mini01 ~]# nginx -v #查看nginx 版本nginx version: nginx/1.12.2[root@mini01 nginx]# whereis nginx #查看nginx 安装位置nginx: /usr/sbin/nginx /etc/nginx /usr/lib64/nginx /usr/share/nginx /usr/share/man/man8/nginx.8.gz 修改nginx配置文件nginx.conf,部署静态页面目录所在位置 1234567891011121314[root@mini01 nginx]# cd /etc/nginx/[root@mini01 nginx]# ll总用量 36drwxr-xr-x. 2 root root 4096 11月 24 07:38 conf.d-rw-r--r--. 1 root root 1007 10月 17 21:25 fastcgi_params-rw-r--r--. 1 root root 2837 10月 17 21:25 koi-utf-rw-r--r--. 1 root root 2223 10月 17 21:25 koi-win-rw-r--r--. 1 root root 3957 10月 17 21:25 mime.typeslrwxrwxrwx. 1 root root 29 11月 24 07:38 modules -&gt; ../../usr/lib64/nginx/modules-rw-r--r--. 1 root root 643 10月 17 21:21 nginx.conf-rw-r--r--. 1 root root 636 10月 17 21:25 scgi_params-rw-r--r--. 1 root root 664 10月 17 21:25 uwsgi_params-rw-r--r--. 1 root root 3610 10月 17 21:25 win-utf[root@mini01 nginx]# cat nginx.conf 发现include /etc/nginx/conf.d/*.conf;然后进入/etc/nginx/conf.d/目录 12345[root@mini01 nginx]# cd conf.d/[root@mini01 conf.d]# ll总用量 4-rw-r--r--. 1 root root 1093 10月 17 21:21 default.conf[root@mini01 conf.d]# vim default.conf 找到： 1234location / &#123; root /usr/share/nginx/html; index index.html index.htm; &#125; 修改为： 1234location / &#123; root /www/hexo; index index.html index.htm; &#125; 效果如下：保存并退出然后启动nginx,这时应该就可以通过ip访问到页面了 启动命令 service nginx start停止命令 service nginx stop重启命令 service nginx restart 123456789[root@mini01 conf.d]# service nginx start正在启动 nginx： [确定][root@mini01 conf.d]# service iptables stopiptables：将链设置为政策 ACCEPT：filter [确定]iptables：清除防火墙规则： [确定]iptables：正在卸载模块： [确定][root@mini01 conf.d]# chkconfig iptables off #关闭开机启动[root@mini01 conf.d]# service iptables status #查看防火墙状态iptables：未运行防火墙。 本地游览器输入ip访问 域名配置如有你的服务器有公网ip的话，在域名管理界面配置域名，然后解析到该ip就可以通过域名访问了过几分钟，就可以通过 test.yangyl.top访问到blog了 参考资料： linux 安装git 服务端并设置钩子自动更新服务器 Nginx采用yum安装方式及安装后的目录]]></content>
      <tags>
        <tag>git</tag>
        <tag>hexo</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git服务器搭建]]></title>
    <url>%2F2017%2F11%2F29%2Fgit_server_build%2F</url>
    <content type="text"><![CDATA[系统环境 CentOS7(64位) Xshell 5 环境搭建服务器安装git我使用的是root账号1[root@mini01 ~]# yum install -y git #使用yum方式安装 查看是否安装成功 12[root@mini01 ~]# git --version #查询git版本git version 1.8.3.1 创建git用户，管理git服务1234567891011[root@mini01 ~]# useradd git #创建git用户[root@mini01 ~]# passwd git更改用户 git 的密码 。新的 密码：无效的密码： 密码少于 8 个字符重新输入新的 密码：passwd：所有的身份验证令牌已经成功更新。[root@mini01 ~]# cd /home #切换到home路径[root@mini01 home]# ll #查询有那些用户总用量 0drwx------. 2 git git 62 11月 29 15:45 git 创建密码的时候，如果输入的是简单密码的话会提示无效的密码： 密码少于 8 个字符之类，不用管它继续输入就行 创建git仓库1234567891011121314151617181920212223242526[root@mini01 home]# cd git #进入git目录 mkdir -p ./repository/gittest.git #创建repository仓库及gittest.git测试项目目录[root@mini01 git]# ll总用量 0drwxr-xr-x. 3 root root 25 11月 29 15:58 repository[root@mini01 git]# cd repository/[root@mini01 repository]# ll总用量 0drwxr-xr-x. 2 root root 6 11月 29 15:58 gittest.git[root@mini01 repository]# git init --bare ./gittest.git #初始化裸仓库初始化空的 Git 版本库于 /home/git/repository/gittest.git/[root@mini01 repository]# ll ./gittest.git/ #查看gittest.git目录的结构总用量 12drwxr-xr-x. 2 root root 6 11月 29 16:03 branches-rw-r--r--. 1 root root 66 11月 29 16:03 config-rw-r--r--. 1 root root 73 11月 29 16:03 description-rw-r--r--. 1 root root 23 11月 29 16:03 HEADdrwxr-xr-x. 2 root root 242 11月 29 16:03 hooksdrwxr-xr-x. 2 root root 21 11月 29 16:03 infodrwxr-xr-x. 4 root root 30 11月 29 16:03 objectsdrwxr-xr-x. 4 root root 31 11月 29 16:03 refs[root@mini01 repository]# cd ../[root@mini01 git]# chown -R git:git repository/ #将拥有者改为git用户[root@mini01 git]# ll总用量 0drwxr-xr-x. 3 git git 25 11月 29 15:58 repository 本地克隆服务器gittest.git项目我使用的win10系统，本地安装好git后，右键进入Git Bash 123456789101112131415161718192021222324lyy0525@DESKTOP-LHUF29F MINGW64 /d$ cd e: #进入e盘lyy0525@DESKTOP-LHUF29F MINGW64 /e$ mkdir gittestlyy0525@DESKTOP-LHUF29F MINGW64 /e$ cd gittest/lyy0525@DESKTOP-LHUF29F MINGW64 /e/gittest$ git clone git@服务器公网IP地址:/home/git/repository/gittest.git ./ #IP地址后面跟冒号，冒号后面是刚才初始化的项目文件夹的绝对路径 ./指定克隆当前目录lyy0525@DESKTOP-LHUF29F MINGW64 /e/gittest$ git clone git@192.168.200.130:/home/git/repository/gittest.gitCloning into &apos;gittest&apos;...The authenticity of host &apos;192.168.200.130 (192.168.200.130)&apos; can&apos;t be established.ECDSA key fingerprint is SHA256:lVUk+TDLLas5oGaQLBteDAOHZWUWL+fSm6sScDSDtVE.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added &apos;192.168.200.130&apos; (ECDSA) to the list of known hosts.git@192.168.200.130&apos;s password:warning: You appear to have cloned an empty repository.lyy0525@DESKTOP-LHUF29F MINGW64 /e/gittest (master)$ ll -a #查看所有文件total 8drwxr-xr-x 1 lyy0525 197121 0 11月 29 16:29 ./drwxr-xr-x 1 lyy0525 197121 0 11月 29 16:16 ../drwxr-xr-x 1 lyy0525 197121 0 11月 29 16:29 .git/ 客户端创建 SSH 公钥和私钥1ssh-keygen -t rsa -C &quot;邮箱地址&quot; 默认会生成到C:\Users\用户名.ssh文件夹下id_rsa 私钥id_rsa.pub 公钥 服务器打开RSA认证1234567[root@mini01 git]# vi /etc/ssh/sshd_config #编辑配置文件#去掉下面三行的#号 RSAAuthentication yesPubkeyAuthentication yesAuthorizedKeysFile .ssh/authorized_keys[root@mini01 git]# service sshd restartRedirecting to /bin/systemctl restart sshd.service 在 /home/git/ 下创建.ssh目录及.ssh目录下的authorized_key文件 12345678910111213141516171819202122[root@mini01 git]# cd /home/git/[root@mini01 git]# pwd/home/git[root@mini01 git]# ll -a总用量 12drwx------. 4 git git 92 11月 29 16:45 .drwxr-xr-x. 3 root root 17 11月 29 15:45 ..-rw-r--r--. 1 git git 18 8月 3 2016 .bash_logout-rw-r--r--. 1 git git 193 8月 3 2016 .bash_profile-rw-r--r--. 1 git git 231 8月 3 2016 .bashrcdrwxr-xr-x. 3 git git 25 11月 29 15:58 repositorydrwxr-xr-x. 2 root root 6 11月 29 16:45 .ssh[root@mini01 git]# cd .ssh/[root@mini01 .ssh]# vim authorized_keys #编辑authorized_keys并把刚才生成的id_rsa.pub中的内容，粘贴进去，保存并退出[root@mini01 .ssh]# ll总用量 4-rw-r--r--. 1 root root 395 11月 29 16:47 authorized_keys[root@mini01 .ssh]# cat authorized_keys #查看文件内容[root@mini01 .ssh]# cd ../[root@mini01 git]# chown -R git:git .ssh/ #改变文件所属用户[root@mini01 git]# ll -a | grep .sshdrwxr-xr-x. 2 git git 29 11月 29 16:47 .ssh 修改 .ssh 目录的权限为 700修改 .ssh/authorized_keys 文件的权限为 600 12[root@mini01 git]# chmod 700 .ssh[root@mini01 git]# chmod 600 .ssh/authorized_keys 本地pull项目这次不用再输入密码 1234lyy0525@DESKTOP-LHUF29F MINGW64 /e/gittest (master)$ git pullYour configuration specifies to merge with the ref &apos;refs/heads/master&apos;from the remote, but no such ref was fetched. 禁止 git 用户 ssh 登录服务器编辑 /etc/passwd 123[root@mini01 git]# whereis git-shell #首先查看git-shell 所在位置git-shell: /usr/bin/git-shell /usr/share/man/man1/git-shell.1.gz[root@mini01 git]# vim /etc/passwd #编辑文件 找到 ：git:x:1000:1000::/home/git:/bin/bash 修改为 ：git:x:1000:1000::/home/git:/usr/bin/git-shell 保存并退出，这时git用户就不可以ssd登陆了，但是还可以管理git项目 参考资料： Linux服务器配置之Git服务器搭建]]></content>
      <tags>
        <tag>git</tag>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小说爬取二]]></title>
    <url>%2F2017%2F11%2F21%2Fbiquge-download2%2F</url>
    <content type="text"><![CDATA[前言前一篇我已经写过一套代码方案了，基本上能够达到我想要的目的，但是只能开一个线程顺序运行，速度有些限制。于是，我变思考了另一种方案，方案的大体思路是下载页面的时候，启动多个线程进行，每一章分别保存到本地，文件名为章节序号名，最后在合并成一个文件。这样就不存在并发问题了，章节顺序也不会错乱。 具体代码爬虫处理及解析类有部分变动主要添加添加代码：page.putField(&quot;title&quot;,title); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 爬虫处理及解析类 */public class BiQuGePageProcessor implements PageProcessor &#123; private Site site = Site.me().setRetryTimes(3).setSleepTime(200).setCharset(&quot;UTF-8&quot;).setTimeOut(10000); private String replaceStr = &quot;\n&quot; + (char) 12288 + (char) 12288;//替换后字符串 @Override public void process(Page page) &#123; List&lt;String&gt; all = page.getHtml().css(&quot;div.bottem2&quot;).links().all();//获取链接 if (all.get(1).equals(all.get(2))) &#123;//如果下一章链接内容 和目录链接相同 说明到最后一章了 page.putField(&quot;end&quot;, &quot;end&quot;);//设置结束标记 &#125; else &#123; page.addTargetRequest(all.get(2));//添加下一章的链接到处理队列 &#125; //解析文章标题 String title = page.getHtml().xpath(&quot;//div[@class=bookname]/h1/text()&quot;).toString(); page.putField(&quot;title&quot;,title); //解析文档内容 String content = page.getHtml().xpath(&quot;//div[@id=content]/text()&quot;).toString(); content = content.replaceAll((char) 12288 + &quot;&#123;2,&#125;&quot;, replaceStr) //(char)12288 全角空格 两个以上全角空格替换为换行符加两个全角空格 .replaceAll((char) 160 + &quot;&#123;2,&#125;&quot;, replaceStr); // (char)160 半角空格 两个以上半角空格替换为换行符加两个全角空格 //设置要处理的文件内容 page.putField(&quot;content&quot;, title + replaceStr + content); &#125; @Override public Site getSite() &#123; return site; &#125; public static void main(String[] args) throws Exception &#123; HttpClientDownloader httpClientDownloader = new HttpClientDownloader(); //设置代理ip// httpClientDownloader.setProxyProvider(SimpleProxyProvider.from(// new Proxy(&quot;221.233.62.43&quot;,808)// ,new Proxy(&quot;125.124.161.221&quot;,808))); httpClientDownloader.setThread(30); //启动爬虫 Spider.create(new BiQuGePageProcessor()) .addUrl(&quot;http://www.biqudu.com/0_903/1823602.html&quot;) .addPipeline(new NovelPipeline2(&quot;D:\\data&quot;)) .thread(10).run();//启动多个线程的话，章节顺序可能会错乱 &#125;&#125; 修改NovelPipeline为NovelPipeline2 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152** * 此类参考JsonFilePipeline改造 */public class NovelPipeline2 extends FilePersistentBase implements Pipeline &#123; private Logger logger = LoggerFactory.getLogger(getClass()); public NovelPipeline2(String path) &#123; setPath(path); &#125; @Override public void process(ResultItems resultItems, Task task) &#123; //没有标题的文章不添加 String title=(String)resultItems.get(&quot;title&quot;); String fileName = getFileName(title); if(StringUtils.isBlank(fileName))&#123; return; &#125; try &#123; PrintWriter printWriter = new PrintWriter(new FileWriter(getFile(path+fileName+ &quot;.txt&quot;))); printWriter.write((String)resultItems.get(&quot;content&quot;)); printWriter.close(); &#125; catch (IOException e) &#123; logger.warn(&quot;write file error&quot;, e); &#125; &#125; //获取文件名 private String getFileName(String title)&#123; if(StringUtils.isBlank(title))&#123; return &quot;&quot;; &#125; //转换章节名为阿拉伯数字 String pattern=(char)32+&quot;*第(.+)章&quot;+(char)32+&quot;.*&quot;; Pattern p = Pattern.compile(pattern); Matcher m = p.matcher(title); if(m.find())&#123; if(m.group(1)!=null)&#123; try &#123; //格式化文件名 return String.format(&quot;%1$04d&quot;, Long.parseLong(m.group(1))); &#125;catch (Exception e)&#123; return String.format(&quot;%1$04d&quot;,ChinessToNum.convert(m.group(1))); &#125; &#125; &#125; return &quot;&quot;; &#125;&#125; 中文数字转阿拉伯数字工具类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116/** * 中文数字转阿拉伯数字工具类 * 该工具类没有做大量测试，可能会有bug存在 */public class ChinessToNum &#123; private static final Map&lt;String,Long&gt; number=new HashMap(); private static final Map&lt;String,Long&gt; units=new LinkedHashMap&lt;&gt;(); static &#123; number.put(&quot;零&quot;,0L); number.put(&quot;一&quot;,1L); number.put(&quot;二&quot;,2L); number.put(&quot;三&quot;,3L); number.put(&quot;四&quot;,4L); number.put(&quot;五&quot;,5L); number.put(&quot;六&quot;,6L); number.put(&quot;七&quot;,7L); number.put(&quot;八&quot;,8L); number.put(&quot;九&quot;,9L); units.put(&quot;千&quot;,1000L); units.put(&quot;百&quot;,100L); units.put(&quot;十&quot;,10L); &#125; /** * 方法一 * 该方法仅适用于小于一万的转换,因为小说章节最多不会超过一万章 * @param chiness * @return */ public static long convert1(String chiness)&#123; chiness=removeZero(chiness); long sum=0L; Set&lt;String&gt; unitSet = units.keySet();// System.out.println(strings); for (String unit:unitSet) &#123; String[] split = chiness.split(unit); if(split.length&gt;1)&#123; if(&quot;十&quot;.equals(unit) &amp;&amp; &quot;&quot;.equals(split[0]))&#123; sum+=10L; &#125;else &#123; sum+=(number.get(split[0])*units.get(unit)); &#125; chiness=split[1]; &#125;else &#123; if( split[0].length()!=chiness.length())&#123; sum+=(number.get(split[0])*units.get(unit)); return sum; &#125; &#125; if(&quot;&quot;.equals(chiness))&#123; return sum; &#125; &#125; sum+=(number.get(chiness)); return sum; &#125; /** * 方法二 * 该方法仅适用于小于一万的转换,因为小说章节最多不会超过一万章 * @param chiness * @return */ public static long convert(String chiness)&#123; long sum=0L; chiness=removeZero(chiness); String pattern3=&quot;((.)千)?((.)百)?((.)?十)?(.*)&quot;; Pattern p = Pattern.compile(pattern3); Matcher m= p.matcher(chiness); if(m.find())&#123;// System.out.println(&quot;Found value: &quot; + m.group(0) );// System.out.println(&quot;Found value: &quot; + m.group(1) );// System.out.println(&quot;Found value: &quot; + m.group(2) );// System.out.println(&quot;Found value: &quot; + m.group(3) );// System.out.println(&quot;Found value: &quot; + m.group(4) );// System.out.println(&quot;Found value: &quot; + m.group(5) );// System.out.println(&quot;Found value: &quot; + m.group(6) );// System.out.println(&quot;Found value: &quot; + m.group(7) ); sum+=(getNum(m.group(2),false)*1000L); sum+=(getNum(m.group(4),false)*100L); sum+=(getNum(m.group(6),m.group(5)!=null)*10L); sum+=(getNum(m.group(7),false)*1L); &#125;// System.out.println(sum); return sum; &#125; //去零操作 private static String removeZero(String chiness)&#123; return chiness.replaceAll(&quot;零&quot;,&quot;&quot;); &#125; private static long getNum(String chiness,boolean isTen)&#123; if(StringUtils.isBlank(chiness))&#123; if(isTen)&#123; return 1L; &#125; return 0L; &#125;else&#123; return number.get(chiness); &#125; &#125; public static void main(String[] args) &#123; System.out.println(ChinessToNum.convert(&quot;&quot;)); &#125;&#125; 文件合并工具类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 文件合并工具类 */public class FileCutUnion &#123; public static void main(String[] args) throws Exception &#123; File fileDir=new File(&quot;D:\\data&quot;); File[] files = fileDir.listFiles(); FileWriter writer=null; try &#123; writer=new FileWriter(&quot;D:\\data\\文件合并.txt&quot;, true); for (File file:files) &#123; FileReader fileReader=null; try &#123; fileReader=new FileReader(file); char[] buf=new char[1024]; int len; while ((len=fileReader.read(buf))!=-1)&#123; writer.write(buf,0,len); writer.flush(); &#125; writer.write(&quot;\n&quot;); writer.flush(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; if(fileReader!=null)&#123; fileReader.close(); &#125; &#125; &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; if(writer!=null)&#123; writer.close(); &#125; &#125; &#125; @Test public void test01()&#123; File fileDir=new File(&quot;D:\\data&quot;); File[] files = fileDir.listFiles(); String[] list = fileDir.list(); for (String fileName:list) &#123; System.out.println(fileName); &#125; Collections.sort(Arrays.asList(files), new Comparator&lt;File&gt;() &#123; @Override public int compare(File o1, File o2) &#123; if (o1.isDirectory() &amp;&amp; o2.isFile()) return -1; if (o1.isFile() &amp;&amp; o2.isDirectory()) return 1; return o1.getName().compareTo(o2.getName()); &#125; &#125;); for (File file:files) &#123; System.out.println(file.getName()); &#125; &#125;&#125;]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小说爬取]]></title>
    <url>%2F2017%2F11%2F20%2Fbiquge_download%2F</url>
    <content type="text"><![CDATA[前言一直想利用爬虫做些事情，但是，就是不知道爬什么好，找不到需求。前几天看儒道至圣这本小说，看了一部分之后，想看看里面是否写有李白的侠客行这首诗，于是我先通过目录看了下没看到，于是我便想把它整个下下来，再在里面全文搜索，看看有没有这几个关键字。所以，我想到用爬虫把文章都爬下来，网上下载小说的网站应该也都有，但是，我刚好找到了一个需求，所以，我没有通过网站直接下载txt文件的方式，而是采用，自己写代码的方式。 环境依赖我用的是以前写的maven项目，只是在里面加了WebMagic (java的一个爬虫框架)的相关依赖12345678910&lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-core&lt;/artifactId&gt; &lt;version&gt;0.7.3&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;us.codecraft&lt;/groupId&gt; &lt;artifactId&gt;webmagic-extension&lt;/artifactId&gt; &lt;version&gt;0.7.3&lt;/version&gt;&lt;/dependency&gt; 添加log4j.properties 文件 页面分析 url 分析提取 标题分析 内容分析 项目结构 具体代码 BiQuGePageProcessor.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 爬虫处理及解析类 */public class BiQuGePageProcessor implements PageProcessor &#123; private Site site = Site.me().setRetryTimes(3).setSleepTime(200).setCharset(&quot;UTF-8&quot;).setTimeOut(10000); private String replaceStr = &quot;\n&quot; + (char) 12288 + (char) 12288;//替换后字符串 @Override public void process(Page page) &#123; List&lt;String&gt; all = page.getHtml().css(&quot;div.bottem2&quot;).links().all();//获取链接// System.out.println(all.get(2)); if (all.get(1).equals(all.get(2))) &#123;//如果下一章链接内容 和目录链接相同 说明到最后一章了 page.putField(&quot;end&quot;, &quot;end&quot;);//设置结束标记 &#125; else &#123; page.addTargetRequest(all.get(2));//添加下一章的链接到处理队列 &#125; //解析文章标题 String title = page.getHtml().xpath(&quot;//div[@class=bookname]/h1/text()&quot;).toString();// System.out.println(title); //解析文档内容 String content = page.getHtml().xpath(&quot;//div[@id=content]/text()&quot;).toString(); content = content.replaceAll((char) 12288 + &quot;&#123;2,&#125;&quot;, replaceStr) //(char)12288 全角空格 两个以上全角空格替换为换行符加两个全角空格 .replaceAll((char) 160 + &quot;&#123;2,&#125;&quot;, replaceStr); // (char)160 半角空格 两个以上半角空格替换为换行符加两个全角空格// System.out.println(content); //设置要处理的文件内容 page.putField(&quot;content&quot;, title + replaceStr + content); &#125; @Override public Site getSite() &#123; return site; &#125; public static void main(String[] args) throws Exception &#123; //指定输出的文件地址 final FileWriterUtil writer = new FileWriterUtil(&quot;D:\\data\\test12.txt&quot;); //启动输出线程 new Thread(new Runnable() &#123; @Override public void run() &#123; writer.startWriter(); &#125; &#125;).start(); HttpClientDownloader httpClientDownloader = new HttpClientDownloader(); //设置代理ip// httpClientDownloader.setProxyProvider(SimpleProxyProvider.from(// new Proxy(&quot;221.233.62.43&quot;,808)// ,new Proxy(&quot;125.124.161.221&quot;,808))); httpClientDownloader.setThread(20); //启动爬虫 Spider.create(new BiQuGePageProcessor()) .addUrl(&quot;http://www.biqudu.com/0_903/2506200.html&quot;) .addPipeline(new NovelPipeline()) .thread(1).run();//启动多个线程的话，章节顺序可能会错乱 &#125;&#125; NovelPipeline.java 123456789101112131415/*** * 解析完后的处理类 * 该类作用不大 可以把代码放进 BiQuGePageProcessor.process里 */public class NovelPipeline implements Pipeline &#123; @Override public void process(ResultItems resultItems, Task task) &#123; //放入输出队列 FileWriterUtil.putContent((String) resultItems.get(&quot;content&quot;)); if (resultItems.get(&quot;end&quot;) != null) &#123; FileWriterUtil.putContent((String) resultItems.get(&quot;end&quot;)); &#125; &#125;&#125; FileWriterUtil.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * 文件输出类 */public class FileWriterUtil &#123; //输出队列 private static final BlockingQueue&lt;String&gt; queue=new LinkedBlockingDeque(20); //文件名 private String fileName; public FileWriterUtil(String fileName) throws Exception &#123; this.fileName=fileName; File file=new File(fileName); //校验文件目录和文件是否存在 不存在则创建 if(!file.getParentFile().exists())&#123; file.getParentFile().mkdirs(); &#125; if(!file.exists())&#123; file.createNewFile(); &#125; &#125; public void startWriter()&#123; FileWriter writer = null; try &#123; // 打开一个写文件器，构造函数中的第二个参数true表示以追加形式写文件 writer = new FileWriter(fileName, true); while (true)&#123; String msg = queue.take(); if(&quot;end&quot;.equals(msg))&#123; break; &#125; writer.write(msg+System.getProperty(&quot;line.separator&quot;)); writer.flush(); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(writer != null)&#123; writer.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //放入队列方法 public static void putContent(final String msg)&#123; try &#123; boolean offer = queue.offer(msg, 1, TimeUnit.MINUTES); if(!offer)&#123; throw new RuntimeException(&quot;队列已满&quot;); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 代码说明代码运行可能会有些慢，为了保证章节不会错乱，只开了一个线程，而且，运行过程可能会报错，下载页面超时的原因，解决方法是，private Site site = Site.me().setRetryTimes(3).setSleepTime(200).setCharset(&quot;UTF-8&quot;).setTimeOut(10000);，timeOut的值设置大点会好一些。 或者需要强制结束程序，再将失败的url复制到main方法里面，再次运行就好了。]]></content>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[主动推送百度搜索]]></title>
    <url>%2F2017%2F11%2F17%2Fproactive-push%2F</url>
    <content type="text"><![CDATA[环境依赖博客搭建好之后，接下准备让百度可以搜索到我的博客，下面是java使用httpClient实现主动推送链接的代码。首先是搭建maven项目，添加pom依赖,httpclient依赖和junit(测试用可以不加)12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt; &lt;artifactId&gt;httpclient&lt;/artifactId&gt; &lt;version&gt;4.5.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt;&lt;/dependency&gt; 项目结构 push-url.txt文件内容格式 具体代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * 百度搜索自动推送代码 */public class InitativeBaiduPush &#123; //你的域名 private static String site=&quot;yangyl.top&quot;; //你的token private static String token=&quot;&quot;; //百度推送的地址 private static String url=&quot;http://data.zz.baidu.com/urls?site=&quot;+site+&quot;&amp;token=&quot;+token; public static void main(String[] args) throws IOException &#123; String urls = getUrls();//获取提交的url if(&quot;&quot;.equals(urls.trim()))&#123; System.out.println(&quot;待提交url为空或文件读取失败&quot;); return; &#125; //使用httpClient发送post请求 CloseableHttpResponse response = null; CloseableHttpClient httpClient = null; try &#123; //请求配置 RequestConfig config = RequestConfig.custom().setConnectTimeout(60000).setSocketTimeout(15000).build(); httpClient = HttpClientBuilder.create().setDefaultRequestConfig(config).build(); HttpPost httpPost=new HttpPost(url); httpPost.setHeader(&quot;Content-Type&quot;,&quot;text/plain&quot;);//可以注释到 StringEntity entity = new StringEntity(urls, Charset.forName(&quot;UTF-8&quot;)); entity.setContentEncoding(&quot;UTF-8&quot;); httpPost.setEntity(entity); response = httpClient.execute(httpPost); printResult(response); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; //关闭连接 if (response != null) &#123; try &#123; response.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (httpClient != null) &#123; try &#123; httpClient.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; /** * 从文件中获取需要提交的url * @return */ private static String getUrls()&#123; StringBuilder sb=new StringBuilder(); try &#123; InputStream stream = InitativeBaiduPush.class.getClassLoader().getResourceAsStream(&quot;push-url.txt&quot;); BufferedReader br=new BufferedReader(new InputStreamReader(stream)); int len; char[] cbuf=new char[1024]; while ((len=br.read(cbuf))!=-1)&#123; sb.append(cbuf,0,len); &#125; //下面这种方法也行// String s;// while ((s=br.readLine())!=null)&#123;// sb.append(s).append(&quot;\n&quot;);// &#125;// System.out.println(sb.toString().length());// return sb.toString().replaceAll(&quot;\\n+$&quot;,&quot;&quot;);//去掉最后的回车符，该行可以注释到 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return sb.toString(); &#125; /** * 打印响应结果到控制台 * @param response * @throws Exception */ private static void printResult(CloseableHttpResponse response) throws Exception &#123; int code = response.getStatusLine().getStatusCode(); System.out.println(code);// System.out.println(response.getStatusLine().getReasonPhrase()); if(code==200)&#123; System.out.println(&quot;主动推送成功&quot;); &#125;else &#123; System.out.println(&quot;主动推送失败&quot;); &#125; if(response.getEntity()!=null)&#123; System.out.println(EntityUtils.toString(response.getEntity(), &quot;UTF-8&quot;)); &#125; &#125; @Test public void testGetUrl()&#123;// System.out.println(getUrls().length()); System.out.println(getUrls()); &#125;&#125; 响应结果123200主动推送成功&#123;&quot;remain&quot;:4999990,&quot;success&quot;:2&#125;]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown学习一]]></title>
    <url>%2F2017%2F11%2F16%2Fmarkdown-learn(1)%2F</url>
    <content type="text"><![CDATA[前言 这几天学习markdown，看了下它的基本语法，感觉不是很多，但是，等到自己动手写的时候，感觉不怎么顺利。所以再下面记录下学习中遇到的问题。注：本文仅供个人记录使用，如有不对之处，请谅解。 一. 首行缩进 按照往常我们写作的习惯都喜欢首行缩进，这样看着有条理一些。所以我看了下markdown的语法，主要是看别人写的博客，没有看官方的文档，发现并没有说明怎么首行缩进的，于是我又查了查，发现可以基于html中的 &amp;nbsp;,因为markdown支持html解析。但是中文的效果不怎么好,然后有试了下 &amp;ensp;,效果强了点，是半角的空格，接着又试了下 &amp;emsp;，是全角的空格,感觉很好两个就是中文的两个空格。最后又试了下把输入法切换成全角，再敲两个空格也可以。 二. 居中 文字居中显示，md中好像没有居中的语法，但是也可以首行缩进一样，借助html的语法，一开始使用的是 &lt;center&gt;&lt;/center&gt;,但是该标签已经废弃，需要使用css。因为我要实现的样式很简单，不想单独写css,于是我使用 &lt;div align=&quot;center&quot; style=&quot;font-size:25px&quot;&gt;文字展示&lt;/div&gt;，这样可以实现文字居中并能够设置字体的大小。 参考资料： markdown中实现首行缩进的两种方法 Markdown 语法手册 （完整整理版）]]></content>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo 环境配置]]></title>
    <url>%2F2017%2F11%2F14%2Fhexo-environment%2F</url>
    <content type="text"><![CDATA[window 环境配置node安装及git安装这个没有什么好说的，直接百度下载安装包，安装就好了。 hexo安装这个看网上的教程写的基本上都是直接在gitbash中执行 npm install -g hexo-cli, 但是，我执行之后反应很慢，或直接没有反应，安装不成功。我感觉是网的问题， 后来百度发现可以替换官方的源为淘宝的源，命令为 npm install -g cnpm --registry=https://registry.npm.taobao.org 然后,就可以使用cnpm 命令了，所以执行 cnpm install -g hexo-cli 执行 hexo version 查看安装版本 hexo项目克隆执行 hexo init 命令，我的电脑克隆项目成功但是执行 npm install 下载依赖没有反应， 使用 cnpm install 下载成功 hexo项目本地运行hexo g #完整命令为hexo generate,用于生成静态文件 hexo s #完整命令为hexo server,用于启动服务器，主要用来本地预览 hexo d #完整命令为hexo deploy,用于将本地文件发布到github上 hexo n #完整命令为hexo new,用于新建一篇文章 参考资料： hexo干货系列：（一）hexo+gitHub搭建个人独立博客 hexo的环境搭建]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F11%2F14%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
